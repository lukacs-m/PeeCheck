//
//  ResultsViewController.swift
//  PeeCheck
//
//  Created by Martin Lukacs on 22/04/2019.
//  Copyright (c) 2019 Martin Lukacs. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftIcons
import Cards
import SnapKit
import MaterialComponents

protocol ResultsDisplayLogic: class {
    func displayUserData(viewModel: MainResults.FetchUserData.ViewModel)
}

final class ResultsViewController: UIViewController, ResultsDisplayLogic, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    var interactor: ResultsBusinessLogic?
    var router: (NSObjectProtocol & ResultsRoutingLogic & ResultsDataPassing)?
//    var displayedInformations: [MainResults.FetchUserData.ViewModel.DisplayedInformation] = []
//    var displayedConclusion: MainResults.FetchUserData.ViewModel.DisplayedConclusion!
    var resultsData: [MainResults.FetchUserData.ViewModel.DisplayedResultElements] = []
    private let collectionView = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewFlowLayout())
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        fetchUserResults()
    }
}

// MARK: Fetches user data from datatabse to be display in subviews

extension ResultsViewController {
    
    func fetchUserResults() {
        let request = MainResults.FetchUserData.Request()
        interactor?.fetchUserData(request: request)
    }
    
    func displayUserData(viewModel: MainResults.FetchUserData.ViewModel) {
        if viewModel.user != nil {
            showAlert(title: "Missing user", message: "Please register your informations for us to be able to process the data. WOuld you like to go to the account page", true)
        }
        if !viewModel.enoughDaysRecording {
            showAlert(title: "Very few data recorded", message: "The conclusion of your redording will not be accurate because of the lack of data. Please record more of your micturitions")
        }
        
        resultsData = viewModel.resultElements
//        displayedInformations = viewModel.informationToDisplay
//        displayedConclusion = viewModel.conclusion
        collectionView.reloadData()
    }
    
    private func showAlert(title: String, message: String, _ moveToAccountPage: Bool = false) {
        let alertController = UIAlertController(title: title, message: message, preferredStyle: .alert)
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        let alertAction = UIAlertAction(title: "OK", style: .default) { _ in
//            if moveToAccountPage {
//                self.router?.goToAccountPage()
//            }
        }
        alertController.addAction(cancelAction)
        alertController.addAction(alertAction)
        self.present(alertController, animated: false, completion: nil)
    }
}

// MARK: Setup

private extension ResultsViewController {
    
    func setup() {
        let viewController = self
        let interactor = ResultsInteractor()
        let presenter = ResultsPresenter()
        let router = ResultsRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    func setupUI() {
        let nav = self.navigationController?.navigationBar
        nav?.isTranslucent = false
        nav?.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.black]
        title = "Results"
        self.navigationController?.navigationBar.prefersLargeTitles = true
        view.backgroundColor = .white
        definesPresentationContext = true
        extendedLayoutIncludesOpaqueBars = true
        configureCollectionView()
    }
    
    func configureCollectionView() {
        view.addSubview(collectionView)
        collectionView.snp.makeConstraints {[weak self] make in
            guard let strongSelf = self else { return }
            make.edges.equalTo(strongSelf.view.safeAreaLayoutGuide)
        }
        title = "Home"
        collectionView.backgroundColor = .clear
        view.addSubview(collectionView)
        collectionView.register(cellType: ResultsCollectionViewCell.self)
        collectionView.register(cellType: MainConclusionCollectionViewCell.self)
        collectionView.delegate = self
        collectionView.dataSource = self
        collectionView.contentInset = UIEdgeInsets(top: 15, left: 15, bottom: 15, right: 15)
        let flow = collectionView.collectionViewLayout as? UICollectionViewFlowLayout // If you create collectionView programmatically then just create this flow by UICollectionViewFlowLayout() and init a collectionView by this flow.
        
        flow?.minimumInteritemSpacing = 15

        flow?.sectionInset = UIEdgeInsets.zero
    }
}

extension ResultsViewController {
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return resultsData.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        switch resultsData[indexPath.item].type {
        case .conclusion:
            return conclusionCollectionView(collectionView, cellForItemAt: indexPath)
        case .day, .night:
            return resultCollectionView(collectionView, cellForItemAt: indexPath)
        case .charts:
            return resultCollectionView(collectionView, cellForItemAt: indexPath)
        }
    }
    
    func resultCollectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        guard let cell = collectionView.dequeueReusableCell(with: ResultsCollectionViewCell.self, for: indexPath) else {
            return UICollectionViewCell()
        }
        
        switch resultsData[indexPath.item].type {
        case .day:
            cell.update(img: "day")
            let destination = AccountViewController()
            cell.displayedCard.shouldPresent(destination, from: self, fullscreen: false)
        case .night:
            cell.update(img: "night1")
            let destination = AccountViewController()
            cell.displayedCard.shouldPresent(destination, from: self, fullscreen: false)
        case .charts:
            cell.update(img: "day")
            let destination = AccountViewController()
            cell.displayedCard.shouldPresent(destination, from: self, fullscreen: false)
        default:
            return UICollectionViewCell()
        }
        
        return cell
    }
    
    func conclusionCollectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        guard let cell = collectionView.dequeueReusableCell(with: MainConclusionCollectionViewCell.self, for: indexPath), let conclusion = resultsData[indexPath.row].conclusion else {
            return UICollectionViewCell()
        }
        
        cell.update(conclusions: conclusion)
        
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
         let dataType = resultsData[indexPath.item].type
        if dataType == .conclusion, let conclusion = resultsData[indexPath.item].conclusion {
        let cell =  MainConclusionCollectionViewCell.fromMTVNib()
        
                    let width = collectionView.bounds.size.width - 30
        
                    cell.contentView.bounds.size.width = width
                    cell.update(conclusions: conclusion)
                    cell.contentView.setNeedsLayout()
                    cell.contentView.layoutIfNeeded()
        
                    let sizeCell = cell.contentView.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize)
                    //        let sizeCell = cell.contentView.systemLayoutSizeFitting(test, withHorizontalFittingPriority: .fittingSizeLevel, verticalFittingPriority: .fittingSizeLevel)
        
                    print("WOOT: height \(sizeCell.height), autre \(cell.intrinsicContentSize.height) ")
        
                    return CGSize(width: width, height: sizeCell.height)
        
        }
       
        
        var width = Style.typeOfDevice() == .pad ? ((view.frame.size.width - 45) / 2)  : view.frame.size.width - 30
        let height = width * (6/5)
        
        if dataType == .conclusion || Style.typeOfDevice() == .pad && dataType == .charts {
            width = view.frame.size.width - 30
        }
        
        return CGSize(width: width, height: height)
    }
}
